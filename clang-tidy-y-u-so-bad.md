# clang-tidy, y u so bad?

If you've ever watched `clang++` compile your code without issues, then run `clang-tidy` only to get:

```
fatal error: 'iostream' file not found
```

and been left scratching your head in confusion...

Welcome to the club.

## What's going on?

<pre>
  <code class="mermaid-diagram">
    graph TD;
      A["User Code"] --> B{"clang++ Driver"};
      B -- "Adds System Includes" --> C["Clang Frontend"];
      C --> D["Compile Object File"];
  
      E["User Code"] --> F{"clang-tidy Tool"};
      F -- "Calls Clang Frontend Directly" --> G["Clang Frontend (Missing System Includes)"];
      G -- "Fails to Find Headers" --> H["Fatal Error: File Not Found"];
  
      style A fill:#f9f,stroke:#333,stroke-width:2px
      style B fill:#bbf,stroke:#333,stroke-width:2px
      style C fill:#ccf,stroke:#333,stroke-width:2px
      style D fill:#9f9,stroke:#333,stroke-width:2px
  
      style E fill:#f9f,stroke:#333,stroke-width:2px
      style F fill:#fbb,stroke:#333,stroke-width:2px
      style G fill:#fcc,stroke:#333,stroke-width:2px
      style H fill:#f66,stroke:#333,stroke-width:2px
  </code>
</pre>

`clang++` acts as a compiler driver. It automatically determines the locations of your system headers, how to find the macOS SDK, and which include paths to add behind the scenes. This involves a set of automatic configurations you don't see by default.

`clang-tidy`, in contrast, is primarily a static analysis tool that *calls Clang's frontend directly*, bypassing the driver's automatic configurations. It relies solely on the information provided to it â€” typically, the `compile_commands.json` generated by CMake.

The problem is that `compile_commands.json` often doesn't contain those vital system include paths.

## Why doesn't CMake export those system paths?

Because CMake assumes the compiler driver (`clang++`) will sort it out during the build. The compile commands are meant to capture *your* explicit flags, not system defaults.

This disconnect means `clang-tidy` sees an incomplete picture and ends up unable to find `<iostream>` or any standard headers.

## What does `clang++` really do?

To see what `clang++` is truly doing, simply run:

```bash
clang++ -v main.cpp
```

You'll see output that should include something like this somewhere:

```
-I/Library/Developer/CommandLineTools/usr/include/c++/v1
-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
```

These paths are silently injected by the driver, remaining hidden from `clang-tidy` unless you explicitly provide them.

## Common Workarounds for This Problem

The most common solutions are:

* Manually specify system paths explicitly when running `clang-tidy`:

    ```bash
    clang-tidy main.cpp -- -std=c++17 \
      -I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1 \
      -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
    ```

* Post-process `compile_commands.json` to inject those flags (see tools like [`fix-compile-commands.py`](https://github.com/Sarcasm/run-clang-tidy/blob/master/fix-compile-commands.py)).

* Use wrapper scripts that query `clang++` for the system includes and dynamically add them when invoking `clang-tidy` on the fly.

Solutions aside, none of these approaches are truly elegant; they often feel like temporary fixes rather than proper solutions.

## The "correct" fix (if you could change clang-tidy)

The real solution is for `clang-tidy` to *call the driver internally* or otherwise reconstruct the full compiler command, including system includes.

Potential approaches include:

* Leveraging Clang's `Driver` APIs to generate a fully expanded command line containing system paths.
* Introducing a flag, perhaps `--infer-system-includes`, that triggers a dry-run of `clang++` to automatically detect and add missing flags.
* Deep integration with existing tools like `clangd`, which already possesses a comprehensive understanding of the full compiler invocation.

None of these have been done `clang-tidy` yet, to my knowledge.

## Why does this matter?

Enabling `CMAKE_EXPORT_COMPILE_COMMANDS=ON` gives the impression that everything should "just work," but in reality, this flag doesn't fully capture the necessary compiler context for tools like `clang-tidy`. As a result, users are often left confused when things break, since the exported commands don't include all the system paths and flags the driver would inject, leading to extra troubleshooting and brittle setups.

Until the Clang ecosystem bridges this gap, native C++ developers face a choice:

* Manually manage system paths across all their tooling, or
* Develop custom scripts to patch or wrap their existing tools.

---

## To conclude

While the problem of `clang-tidy` not finding system headers is a persistent challenge for C++ developers, understanding the distinction between the compiler driver and the frontend is key to navigating these toolchain complexities. Until a more integrated solution is available, manual configuration and custom scripting remain necessary for robust static analysis setups.

---

### Related discussions and resources

* [LLVM Issue #46804: clang-tidy doesn't work correctly when compile_commands.json contains symlink to clang](https://github.com/llvm/llvm-project/issues/46804)
* [Stack Overflow: clang-tidy not finding headers](https://stackoverflow.com/questions/78491627/clang-tidy-not-finding-a-header-file)
* [David Li on clang-tidy & Conda](https://www.lidavidm.me/c++/2023/06/16/c++-clang-tidy-complains-it-can-t-find-common-headers-especially-under-conda-conda-forge.html) (Note: also check if your CC/CXX environment variables point to symlinked compilers.)
* [Stack Overflow: Clang vs clang++ include differences](https://stackoverflow.com/questions/74842298/clang-cant-find-system-headers-without-stdlib-libc)

<script>
const config = {
  startOnLoad:true,
  theme: "forest",
  flowchart: {
      useMaxWidth: false,
      htmlLabels: true
  }
};
mermaid.initialize(config);
window.mermaid.init(undefined, document.querySelectorAll('.mermaid-diagram'));
</script>
